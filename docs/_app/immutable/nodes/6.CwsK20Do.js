import{f as d,a as l}from"../chunks/wtmyQNTq.js";import"../chunks/B8TJi0RM.js";import{a4 as r,a8 as v,a3 as u,a9 as f,aa as g,ab as s,a6 as i,a7 as o}from"../chunks/g7nFBF1M.js";import{h as y}from"../chunks/Chqr_Z16.js";import{s as c}from"../chunks/oxtBfwX0.js";import{b as n}from"../chunks/UR9wHOm1.js";const w=!0,M=Object.freeze(Object.defineProperty({__proto__:null,prerender:w},Symbol.toStringTag,{value:"Module"}));var _=d('<meta name="description" content="Learn how modern functional pseudo-classes actually affect the cascade — and why :where() is a game-changer."/> <meta property="og:title" content="Why :not(), :is(), and :has() Don’t Add Extra Specificity"/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),S=d(`<div class="container fade-in post-layout svelte-1al8b51"><div class="breadcrumbs svelte-1al8b51"><a class="svelte-1al8b51">Blog</a> <span>/</span> <p class="svelte-1al8b51">Modern Pseudo-classes & Specificity</p></div> <article class="prose svelte-1al8b51"><h1 class="svelte-1al8b51">Why :not(), :is(), and :has() Don’t Add Extra Specificity</h1> <p class="post-meta svelte-1al8b51">Published: November 25, 2025</p> <p class="lead svelte-1al8b51">Modern CSS introduced powerful new pseudo-classes like :not(), :is(), :where(), and :has(). But many developers are surprised to learn: <strong>most of them add zero specificity themselves</strong>.</p> <h2 class="svelte-1al8b51">The Old Rule Still Applies</h2> <p class="svelte-1al8b51">Only the selectors <em>inside</em> these functions contribute to specificity. The function wrapper usually adds nothing.</p> <h2 class="svelte-1al8b51">Breakdown by Pseudo-class</h2> <ul class="svelte-1al8b51"><li class="svelte-1al8b51"><strong>:not()</strong> → 0 specificity. Only its argument counts.<br/> <code>:not(.active)</code> → 0-0-1-0</li> <li class="svelte-1al8b51"><strong>:is()</strong> → Uses the <em>highest</em> specificity of its arguments.<br/> <code>:is(article, aside) h1</code> → 0-0-0-2 (same as h1)</li> <li class="svelte-1al8b51"><strong>:where()</strong> → Always 0 specificity — even for its arguments!<br/> <code>:where(#main) .card</code> → 0-0-1-0 (the #main is ignored!)</li> <li class="svelte-1al8b51"><strong>:has()</strong> → 0 specificity for the function itself.<br/> <code>section:has(h2)</code> → 0-0-0-2</li></ul> <div class="alert alert-success my-4 p-4 bg-light border-start border-success border-4"><strong>Pro tip:</strong> Use :where() to write reusable, low-specificity components without specificity wars.</div> <h2 class="svelte-1al8b51">Real-World Example</h2> <pre><code>:where(.card) &#123; padding: 1rem; &#125;        → 0-0-0-0<br/>
.card &#123; padding: 2rem; &#125;                 → 0-0-1-0<br/></code></pre> <p class="svelte-1al8b51">The second rule wins — even though :where() contains a class!</p> <p class="svelte-1al8b51">The second rule wins — even though :where() contains a class!</p> <h2 class="svelte-1al8b51">FAQ</h2> <details class="svelte-1al8b51"><summary class="svelte-1al8b51">Can :has() ever increase specificity?</summary> <p class="svelte-1al8b51">No. The relational selector adds no weight — only the subject and its contents do.</p></details> <details class="svelte-1al8b51"><summary class="svelte-1al8b51">Should I replace all classes with :where()?</summary> <p class="svelte-1al8b51">Only for base styles. Keep meaningful classes for overrides.</p></details> <p class="italic-note svelte-1al8b51">Modern CSS finally gives us tools to write scalable stylesheets — without fighting specificity.</p></article></div>`);function W(p){var e=S();y("1al8b51",m=>{var t=_(),b=v(u(t),4);s(4),r(()=>c(b,"content",`${n??""}/blog/posts/post3`)),f(()=>{g.title="Why :not(), :is(), and :has() Don’t Add Extra Specificity"}),l(m,t)});var a=i(e),h=i(a);s(4),o(a),s(2),o(e),r(()=>c(h,"href",`${n??""}/blog`)),l(p,e)}export{W as component,M as universal};
